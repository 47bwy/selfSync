<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>python 算法 - 47bwy 的学习之路</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "python \u7b97\u6cd5";
        var mkdocs_page_input_path = "03_python/04_python\u7b97\u6cd5.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 47bwy 的学习之路
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Network</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../01_network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Linux</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../02_linux/linux%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%B4%E6%8A%A4/">Linux 使用和维护</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Python</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../00_python%E7%BC%96%E7%A8%8B/">Python 编程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../01_python%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/">Python 数据操作</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../02_python%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F/">Python 编程模式</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../03_python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Python 数据结构</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">python 算法</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#sorting-algorithms">排序算法 (Sorting Algorithms)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#searching-algorithms">搜索算法 (Searching Algorithms)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#graph-algorithms">图算法 (Graph Algorithms)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynamic-programming">动态规划 (Dynamic Programming)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#greedy-algorithms">贪心算法 (Greedy Algorithms)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#divide-and-conquer">分治算法 (Divide and Conquer)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#string-algorithms">字符串算法 (String Algorithms)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#mathematical-algorithms">数学算法 (Mathematical Algorithms)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#machine-learning-algorithms">机器学习算法 (Machine Learning Algorithms)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">其他实用算法</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../05_%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%BA%93/">常用内置库</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93/">常用三方库</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">数据库</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../05_database/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">mysql</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../05_database/redis%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">redis</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../05_database/mongodb%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">mongodb</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Web</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../07_web/01_web%E5%BC%80%E5%8F%91/">web开发</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../07_web/02_flask/">flask</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">blog</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../08_blog/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Books</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../09_books/%E6%8E%A7%E7%B3%96%E9%9D%A9%E5%91%BD/">《控糖革命》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../09_books/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/">《编写可读代码的艺术》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">47bwy 的学习之路</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Python</li>
      <li class="breadcrumb-item active">python 算法</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1"></h1>
<p>Python 作为一门通用编程语言，可以实现各种算法。</p>
<h3 id="sorting-algorithms">排序算法 (Sorting Algorithms)</h3>
<pre><code class="language-python"># 冒泡排序
def bubble_sort(arr):
    n = len(arr)
    for i in range(n-1):
        for j in range(n-i-1):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# 快速排序
def quick_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    pivot = arr[len(arr)//2]
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x &gt; pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 归并排序
def merge_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt; right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
</code></pre>
<h3 id="searching-algorithms">搜索算法 (Searching Algorithms)</h3>
<pre><code class="language-python"># 二分查找
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low &lt;= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] &lt; target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

# 线性查找
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
</code></pre>
<h3 id="graph-algorithms">图算法 (Graph Algorithms)</h3>
<pre><code class="language-python"># 广度优先搜索 (BFS)
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        vertex = queue.popleft()
        print(vertex, end=&quot; &quot;)
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# 深度优先搜索 (DFS)
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=&quot; &quot;)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

# Dijkstra 最短路径算法
import heapq

def dijkstra(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    heap = [(0, start)]

    while heap:
        current_distance, current_vertex = heapq.heappop(heap)
        if current_distance &gt; distances[current_vertex]:
            continue
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            if distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(heap, (distance, neighbor))
    return distances
</code></pre>
<h3 id="dynamic-programming">动态规划 (Dynamic Programming)</h3>
<pre><code class="language-python"># 斐波那契数列 (带记忆化)
def fibonacci(n, memo={}):
    if n in memo:
        return memo[n]
    if n &lt;= 2:
        return 1
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]

# 0-1背包问题
def knapsack(values, weights, capacity):
    n = len(values)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] &lt;= w:
                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]
    return dp[n][capacity]
</code></pre>
<h3 id="greedy-algorithms">贪心算法 (Greedy Algorithms)</h3>
<pre><code class="language-python"># 活动选择问题
def activity_selection(activities):
    activities.sort(key=lambda x: x[1])  # 按结束时间排序
    selected = [activities[0]]

    for activity in activities[1:]:
        if activity[0] &gt;= selected[-1][1]:  # 开始时间 &gt;= 上一个活动的结束时间
            selected.append(activity)
    return selected

# 霍夫曼编码
import heapq

def huffman_coding(freq):
    heap = [[weight, [symbol, &quot;&quot;]] for symbol, weight in freq.items()]
    heapq.heapify(heap)

    while len(heap) &gt; 1:
        lo = heapq.heappop(heap)
        hi = heapq.heappop(heap)
        for pair in lo[1:]:
            pair[1] = '0' + pair[1]
        for pair in hi[1:]:
            pair[1] = '1' + pair[1]
        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])
    return sorted(heapq.heappop(heap)[1:], key=lambda p: (len(p[-1]), p))
</code></pre>
<h3 id="divide-and-conquer">分治算法 (Divide and Conquer)</h3>
<pre><code class="language-python"># 最大子数组问题
def max_subarray(arr):
    def max_crossing_sum(arr, low, mid, high):
        left_sum = float('-inf')
        total = 0
        for i in range(mid, low-1, -1):
            total += arr[i]
            if total &gt; left_sum:
                left_sum = total

        right_sum = float('-inf')
        total = 0
        for i in range(mid+1, high+1):
            total += arr[i]
            if total &gt; right_sum:
                right_sum = total

        return left_sum + right_sum

    def max_subarray_helper(arr, low, high):
        if low == high:
            return arr[low]
        mid = (low + high) // 2
        return max(max_subarray_helper(arr, low, mid),
                  max_subarray_helper(arr, mid+1, high),
                  max_crossing_sum(arr, low, mid, high))

    return max_subarray_helper(arr, 0, len(arr)-1)
</code></pre>
<h3 id="string-algorithms">字符串算法 (String Algorithms)</h3>
<pre><code class="language-python"># KMP 字符串匹配算法
def kmp_search(text, pattern):
    def compute_lps(pattern):
        lps = [0] * len(pattern)
        length = 0
        i = 1
        while i &lt; len(pattern):
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length-1]
                else:
                    lps[i] = 0
                    i += 1
        return lps

    lps = compute_lps(pattern)
    i = j = 0
    while i &lt; len(text):
        if text[i] == pattern[j]:
            i += 1
            j += 1
            if j == len(pattern):
                return i - j
        else:
            if j != 0:
                j = lps[j-1]
            else:
                i += 1
    return -1

# Rabin-Karp 字符串匹配算法
def rabin_karp(text, pattern):
    d = 256  # 字符集大小
    q = 101  # 质数
    m = len(pattern)
    n = len(text)
    p = t = 0
    h = 1

    for i in range(m-1):
        h = (h * d) % q

    for i in range(m):
        p = (d * p + ord(pattern[i])) % q
        t = (d * t + ord(text[i])) % q

    for i in range(n - m + 1):
        if p == t:
            if text[i:i+m] == pattern:
                return i
        if i &lt; n - m:
            t = (d * (t - ord(text[i]) * h) + ord(text[i + m]) % q
            if t &lt; 0:
                t += q
    return -1
</code></pre>
<h3 id="mathematical-algorithms">数学算法 (Mathematical Algorithms)</h3>
<pre><code class="language-python"># 素数筛法 (埃拉托斯特尼筛法)
def sieve_of_eratosthenes(n):
    primes = [True] * (n+1)
    primes[0] = primes[1] = False
    for i in range(2, int(n**0.5)+1):
        if primes[i]:
            for j in range(i*i, n+1, i):
                primes[j] = False
    return [i for i, is_prime in enumerate(primes) if is_prime]

# 最大公约数 (欧几里得算法)
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# 快速幂算法
def fast_power(a, b):
    result = 1
    while b &gt; 0:
        if b % 2 == 1:
            result *= a
        a *= a
        b //= 2
    return result
</code></pre>
<h3 id="machine-learning-algorithms">机器学习算法 (Machine Learning Algorithms)</h3>
<pre><code class="language-python"># K-均值聚类
import numpy as np

def k_means(data, k, max_iterations=100):
    # 随机初始化中心点
    centroids = data[np.random.choice(range(len(data)), k, replace=False)]

    for _ in range(max_iterations):
        # 分配点到最近的聚类中心
        distances = np.sqrt(((data - centroids[:, np.newaxis])**2).sum(axis=2))
        clusters = np.argmin(distances, axis=0)

        # 更新聚类中心
        new_centroids = np.array([data[clusters == i].mean(axis=0) for i in range(k)])

        # 检查是否收敛
        if np.all(centroids == new_centroids):
            break
        centroids = new_centroids

    return clusters, centroids

# 线性回归
def linear_regression(X, y, learning_rate=0.01, iterations=1000):
    m = len(y)
    theta = np.zeros(X.shape[1])

    for _ in range(iterations):
        predictions = X.dot(theta)
        errors = predictions - y
        gradient = X.T.dot(errors) / m
        theta -= learning_rate * gradient

    return theta
</code></pre>
<h3 id="_2">其他实用算法</h3>
<pre><code class="language-python"># LRU缓存 (最近最少使用)
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) &gt; self.capacity:
            self.cache.popitem(last=False)

# 布隆过滤器
import mmh3
from bitarray import bitarray

class BloomFilter:
    def __init__(self, size, hash_num):
        self.size = size
        self.hash_num = hash_num
        self.bit_array = bitarray(size)
        self.bit_array.setall(0)

    def add(self, item):
        for i in range(self.hash_num):
            index = mmh3.hash(item, i) % self.size
            self.bit_array[index] = 1

    def contains(self, item):
        for i in range(self.hash_num):
            index = mmh3.hash(item, i) % self.size
            if not self.bit_array[index]:
                return False
        return True
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../03_python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="btn btn-neutral float-left" title="Python 数据结构"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../05_%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%BA%93/" class="btn btn-neutral float-right" title="常用内置库">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../03_python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../05_%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%BA%93/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
