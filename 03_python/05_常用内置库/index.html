<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>常用内置库 - 47bwy 的学习之路</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u5e38\u7528\u5185\u7f6e\u5e93";
        var mkdocs_page_input_path = "03_python/05_\u5e38\u7528\u5185\u7f6e\u5e93.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> 47bwy 的学习之路
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Network</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../01_network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">网络基础</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Linux</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../02_linux/linux%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%B4%E6%8A%A4/">Linux 使用和维护</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Python</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../00_python%E7%BC%96%E7%A8%8B/">Python 编程</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../01_python%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/">Python 数据操作</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../02_python%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F/">Python 编程模式</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../03_python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Python 数据结构</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../04_python%E7%AE%97%E6%B3%95/">python 算法</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">常用内置库</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#re">re 模块</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_2">正则</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_3">查找</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">替换</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#unicode">在正则式中使用 Unicode</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_5">字符串令牌解析</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#unicodedata">unicodedata 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#collections">collections 模块</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#deque">deque()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defaultdict">defaultdict()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ordereddict">OrderedDict()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#counter">Counter()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#namedtuple">namedtuple()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chainmap">ChainMap</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#heapq">heapq 模块</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#n">从一个集合中获得最大或者最小的 N 个元素列表。</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">顺序迭代合并后的排序迭代对象</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#operator">operator 模块</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#itemgetter">itemgetter()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#attrgetter">attrgetter()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#itertools">itertools 模块</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#islice">islice()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dropwhile">dropwhile()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#permutationscombinationscombinations_with_replacement">permutations()/combinations()/combinations_with_replacement()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#zip_longest">zip_longest()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#chain">chain()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#groupby">groupby()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compress">compress()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#logging">logging 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#time">time 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#datetime">datetime 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#time-datetime">time 和 datetime 对比</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pytz">pytz 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#os">os 模块</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_7">八进制</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#operator_1">operator 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#math">math 模块</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_8">数学函数</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#decimal">decimal 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#fractions">fractions 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#random">random 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#struct">struct 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#hashlib">hashlib 模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#statistics">statistics 模块</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93/">常用三方库</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">数据库</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../05_database/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">mysql</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../05_database/redis%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">redis</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../05_database/mongodb%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">mongodb</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Web</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../07_web/01_web%E5%BC%80%E5%8F%91/">web开发</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../07_web/02_flask/">flask</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">blog</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../08_blog/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Books</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../09_books/%E6%8E%A7%E7%B3%96%E9%9D%A9%E5%91%BD/">《控糖革命》</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../09_books/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/">《编写可读代码的艺术》</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">47bwy 的学习之路</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Python</li>
      <li class="breadcrumb-item active">常用内置库</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1"></h1>
<h3 id="re">re 模块</h3>
<h4 id="_2">正则</h4>
<ul>
<li>最短匹配模式（非贪婪）</li>
<li>多行匹配（<code>re.compile(r'/\*(.*?)\*/', re.DOTALL)</code> 或者 <code>(?:.|\n)</code> 指定一个非捕获组）</li>
</ul>
<h4 id="_3">查找</h4>
<p>如果想匹配的是字面字符串，那么通常只需要调用基本字符串方法就行， 比如 <code>str.find()</code> , <code>str.endswith()</code> , <code>str.startswith()</code> 。</p>
<p>复杂的匹配需要使用正则表达式和 re 模块。</p>
<pre><code class="language-python">&gt;&gt;&gt; text1 = '11/27/2012'
&gt;&gt;&gt; text2 = 'Nov 27, 2012'
&gt;&gt;&gt;
&gt;&gt;&gt; import re
&gt;&gt;&gt; # Simple matching: \d+ means match one or more digits
&gt;&gt;&gt; if re.match(r'\d+/\d+/\d+', text1):
... print('yes')
... else:
... print('no')
...

</code></pre>
<p>如果想使用同一个模式去做多次匹配，你应该先将模式字符串预编译为模式对象。比如：</p>
<pre><code class="language-python">&gt;&gt;&gt; datepat = re.compile(r'\d+/\d+/\d+')
&gt;&gt;&gt; if datepat.match(text1):
... print('yes')
... else:
... print('no')
...
</code></pre>
<p>match() 总是从字符串开始去匹配，如果你想查找字符串任意部分的模式出现位置， 使用 findall() 方法去代替。</p>
<p>在定义正则式的时候，通常会利用括号去捕获分组。</p>
<pre><code class="language-python">&gt;&gt;&gt; datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
&gt;&gt;&gt; text
'Today is 11/27/2012. PyCon starts 3/13/2013.'
&gt;&gt;&gt; datepat.findall(text)
[('11', '27', '2012'), ('3', '13', '2013')]
&gt;&gt;&gt; for month, day, year in datepat.findall(text):
... print('{}-{}-{}'.format(year, month, day))
...
2012-11-27
2013-3-13
&gt;&gt;&gt;
</code></pre>
<p><code>findall()</code> 方法会搜索文本并以列表形式返回所有的匹配。 如果想以迭代方式返回匹配，可以使用 <code>finditer()</code> 方法来代替，比如：</p>
<pre><code class="language-python">&gt;&gt;&gt; for m in datepat.finditer(text):
... print(m.groups())
...
('11', '27', '2012')
('3', '13', '2013')
&gt;&gt;&gt;
</code></pre>
<h4 id="_4">替换</h4>
<p>对于简单的字面模式，直接使用 <code>str.replace()</code> 方法即可，对于复杂的模式，使用 re 模块中的 <code>sub()</code> 函数。</p>
<pre><code class="language-python">&gt;&gt;&gt; text = 'UPPER PYTHON, lower python, Mixed Python'
&gt;&gt;&gt; re.findall('python', text, flags=re.IGNORECASE)
['PYTHON', 'python', 'Python']
&gt;&gt;&gt; re.sub('python', 'snake', text, flags=re.IGNORECASE)
'UPPER snake, lower snake, Mixed snake'
&gt;&gt;&gt;
</code></pre>
<p>上面例子有个缺陷，替换字符串并不会自动跟被匹配字符串的大小写保持一致。</p>
<pre><code class="language-python">def matchcase(word):
    def replace(m):
        text = m.group()
        if text.isupper():
            return word.upper()
        elif text.islower():
            return word.lower()
        elif text[0].isupper():
            return word.capitalize()
        else:
            return word
    return replace

&gt;&gt;&gt; re.sub('python', matchcase('snake'), text, flags=re.IGNORECASE)
'UPPER SNAKE, lower snake, Mixed Snake'
&gt;&gt;&gt;
</code></pre>
<p><code>matchcase('snake')</code> 返回了一个回调函数(参数必须是 <code>match</code> 对象)，前面一节提到过， <code>sub()</code> 函数除了接受替换字符串外，还能接受一个回调函数。</p>
<p>对于一般的忽略大小写的匹配操作，简单的传递一个 re.IGNORECASE 标志参数就已经足够了。但是需要注意的是，这个对于某些需要大小写转换的 Unicode 匹配可能还不够。</p>
<h4 id="unicode">在正则式中使用 Unicode</h4>
<p>默认情况下<code>re</code>模块已经对一些 Unicode 字符类有了基本的支持。 比如，<code>\\d</code> 已经匹配任意的 unicode 数字字符了。</p>
<pre><code class="language-python">&gt;&gt;&gt; import re
&gt;&gt;&gt; num = re.compile('\d+')
&gt;&gt;&gt; # ASCII digits
&gt;&gt;&gt; num.match('123')
&lt;_sre.SRE_Match object at 0x1007d9ed0&gt;
&gt;&gt;&gt; # Arabic digits
&gt;&gt;&gt; num.match('\u0661\u0662\u0663')
&lt;_sre.SRE_Match object at 0x101234030&gt;
&gt;&gt;&gt;
</code></pre>
<p>混合使用Unicode和正则表达式，最好还是使用增强的第三方库，比如： <code>regex</code></p>
<h4 id="_5">字符串令牌解析</h4>
<p>有一个字符串，想从左至右将其解析为一个令牌流。</p>
<p>对于复杂的语法，最好是选择某个解析工具比如 PyParsing 或者是 PLY。</p>
<h3 id="unicodedata">unicodedata 模块</h3>
<p>标准化对于任何需要以一致的方式处理Unicode文本的程序都是非常重要的，当处理来自用户输入的字符串而你很难去控制编码的时候尤其如此。</p>
<pre><code class="language-python">&gt;&gt;&gt; s1 = 'Spicy Jalape\u00f1o'
&gt;&gt;&gt; s2 = 'Spicy Jalapen\u0303o'
&gt;&gt;&gt; s1
'Spicy Jalapeño'
&gt;&gt;&gt; s2
'Spicy Jalapeño'
&gt;&gt;&gt; s1 == s2
False
&gt;&gt;&gt; len(s1)
14
&gt;&gt;&gt; len(s2)
15
&gt;&gt;&gt;

&gt;&gt;&gt; import unicodedata
&gt;&gt;&gt; t1 = unicodedata.normalize('NFC', s1)
&gt;&gt;&gt; t2 = unicodedata.normalize('NFC', s2)
&gt;&gt;&gt; t1 == t2
True
&gt;&gt;&gt; print(ascii(t1))
'Spicy Jalape\xf1o'
&gt;&gt;&gt; t3 = unicodedata.normalize('NFD', s1)
&gt;&gt;&gt; t4 = unicodedata.normalize('NFD', s2)
&gt;&gt;&gt; t3 == t4
True
&gt;&gt;&gt; print(ascii(t3))
'Spicy Jalapen\u0303o'
&gt;&gt;&gt;

&gt;&gt;&gt; t1 = unicodedata.normalize('NFD', s1)
&gt;&gt;&gt; ''.join(c for c in t1 if not unicodedata.combining(c))
'Spicy Jalapeno'
&gt;&gt;&gt;
</code></pre>
<h3 id="collections">collections 模块</h3>
<h4 id="deque">deque()</h4>
<p>在迭代操作或者其他操作的时候，只保留最后有限几个元素的历史记录。<code>deque(maxlen=N)</code>构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。</p>
<p>在队列两端插入或删除元素时间复杂度都是<code>O(1)</code>，区别于列表，在列表的开头插入或删除元素的时间复杂度为<code>O(N)</code>。</p>
<p>在写查询元素的代码时，通常会使用包含<code>yield</code>表达式的生成器函数，这样可以将搜索过程代码和使用搜索结果代码解耦。</p>
<pre><code class="language-python">from collections import deque


def my_search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)
    for line in lines:
        if pattern in line:
            yield line, previous_lines
        previous_lines.append(line)

# Example use on a file
if __name__ == '__main__':
    with open(r'../../cookbook/somefile.txt') as f:
        for line, prevlines in my_search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
            print(line, end='')
            print('-' * 20)
</code></pre>
<h4 id="defaultdict">defaultdict()</h4>
<p>一个字典就是一个键对应一个单值的映射。如果你想要一个键映射多个值，就需要将这多个值放到另外的容器中，比如列表或者集合里面。</p>
<p>可以很方便的使用<code>collections</code>模块中的<code>defaultdict</code>来构造这样的字典。 </p>
<pre><code class="language-python">from collections import defaultdict

d = defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)

d = defaultdict(set)
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)
</code></pre>
<p>需要注意的是， defaultdict 会自动为将要访问的键（就算目前字典中并不存在这样的键）创建映射实体。 </p>
<h4 id="ordereddict">OrderedDict()</h4>
<p>创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。</p>
<p>为了能控制一个字典中元素的顺序，可以使用<code>collections</code>模块中的<code>OrderedDict</code>类。在迭代操作的时候它会保持元素被插入时的顺序</p>
<pre><code class="language-python">from collections import OrderedDict

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4
# Outputs &quot;foo 1&quot;, &quot;bar 2&quot;, &quot;spam 3&quot;, &quot;grok 4&quot;
for key in d:
    print(key, d[key])
</code></pre>
<p><code>OrderedDict</code> 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。</p>
<p>需要注意的是，一个 <code>OrderedDict</code> 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。 所以如果你要构建一个需要大量 <code>OrderedDict</code> 实例的数据结构的时候（比如读取 100,000 行 CSV 数据到一个 <code>OrderedDict</code> 列表中去）， 那么你就得仔细权衡一下是否使用 <code>OrderedDict</code> 带来的好处要大过额外内存消耗的影响。</p>
<h4 id="counter">Counter()</h4>
<p>找出一个序列中出现次数最多的元素</p>
<pre><code class="language-python">words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
    'eyes', &quot;don't&quot;, 'look', 'around', 'the', 'eyes', 'look', 'into',
    'my', 'eyes', &quot;you're&quot;, 'under'
]
from collections import Counter
word_counts = Counter(words)
# 出现频率最高的3个单词
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]
</code></pre>
<h4 id="namedtuple">namedtuple()</h4>
<p><code>collections.namedtuple()</code>这个函数实际上是一个返回 Python 中标准元组类型子类的一个工厂方法。</p>
<p>传递一个类型名和你需要的字段给它，然后它就会返回一个类，可以初始化这个类，为定义的字段传递值等。</p>
<pre><code class="language-python">&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
&gt;&gt;&gt; sub = Subscriber('jonesy@example.com', '2012-10-19')
&gt;&gt;&gt; sub
Subscriber(addr='jonesy@example.com', joined='2012-10-19')
&gt;&gt;&gt; sub.addr
'jonesy@example.com'
&gt;&gt;&gt; sub.joined
'2012-10-19'
&gt;&gt;&gt;
</code></pre>
<p>尽管 <code>namedtuple</code> 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。 比如：</p>
<pre><code class="language-python">&gt;&gt;&gt; len(sub)
2
&gt;&gt;&gt; addr, joined = sub
&gt;&gt;&gt; addr
'jonesy@example.com'
&gt;&gt;&gt; joined
'2012-10-19'
&gt;&gt;&gt;
</code></pre>
<p>命名元组的一个主要用途是将代码从下标操作中解脱出来。 因此，在数据库调用中返回了一个很大的元组列表的情况下，使用命名元组增删就会很方便。</p>
<pre><code class="language-python">def compute_cost(records):
    total = 0.0
    for rec in records:
        total += rec[1] * rec[2]
    return total
</code></pre>
<p>下标操作通常会让代码表意不清晰，并且非常依赖记录的结构。 下面是使用命名元组的版本：</p>
<pre><code class="language-python">from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])
def compute_cost(records):
    total = 0.0
    for rec in records:
        s = Stock(*rec)
        total += s.shares * s.price
    return total
</code></pre>
<p>命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。 如果需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效。 但是需要注意的是，不像字典那样，一个命名元组是不可更改的。比如：</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('ACME', 100, 123.45)
&gt;&gt;&gt; s
Stock(name='ACME', shares=100, price=123.45)
&gt;&gt;&gt; s.shares = 75
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can't set attribute
&gt;&gt;&gt;
</code></pre>
<p>如果真的需要改变属性的值，那么可以使用命名元组实例的 <code>_replace()</code> 方法， 它会创建一个全新的命名元组并将对应的字段用新的值取代。比如：</p>
<pre><code class="language-python">&gt;&gt;&gt; s = s._replace(shares=75)
&gt;&gt;&gt; s
Stock(name='ACME', shares=75, price=123.45)
&gt;&gt;&gt;
</code></pre>
<h4 id="chainmap">ChainMap</h4>
<p>现在有多个字典或者映射，将它们从逻辑上合并为一个单一的映射后执行某些操作，比如查找值或者检查某些键是否存在。</p>
<pre><code class="language-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
from collections import ChainMap
c = ChainMap(a,b)
print(c['x']) # Outputs 1 (from a)
print(c['y']) # Outputs 2 (from b)
print(c['z']) # Outputs 3 (from a)
</code></pre>
<p>一个 <code>ChainMap</code> 接受多个字典并将它们在逻辑上变为一个字典。 然后，这些字典并不是真的合并在一起了， <code>ChainMap</code> 类只是在内部创建了一个容纳这些字典的列表 并重新定义了一些常见的字典操作来遍历这个列表。大部分字典操作都是可以正常使用。</p>
<p>与 <code>update()</code> 不同的是：使用 <code>update</code> 如果原字典做了更新，这种改变不会反应到新的合并字典中去。<code>ChainMap</code> 使用原来的字典，它自己不创建新的字典，所以会随之改变。</p>
<h3 id="heapq">heapq 模块</h3>
<h4 id="n">从一个集合中获得最大或者最小的 N 个元素列表。</h4>
<p>heapq 模块有两个函数：<code>nlargest()</code>和<code>nsmallest()</code>可以完美解决这个问题。</p>
<pre><code class="language-python">import heapq
nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]
</code></pre>
<p>在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中。</p>
<p>堆数据结构最重要的特征是<code>heap[0]</code>永远是最小的元素。并且剩余的元素可以很容易的通过调用<code>heapq.heappop()</code>方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是<code>O(log N)</code>，<code>N</code>是堆大小）。</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
&gt;&gt;&gt; import heapq
&gt;&gt;&gt; heap = list(nums)
&gt;&gt;&gt; heapq.heapify(heap)
&gt;&gt;&gt; heap
[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
&gt;&gt;&gt;
</code></pre>
<p>当要查找的元素个数相对比较小的时候，函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 是很合适的。 如果你仅仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 <code>min()</code> 和 <code>max()</code> 函数会更快些。 类似的，如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 （ <code>sorted(items)[:N]</code> 或者是 <code>sorted(items)[-N:]</code> ）。 需要在正确场合使用函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 才能发挥它们的优势 （如果 N 快接近集合大小了，那么使用排序操作会更好些）。</p>
<h4 id="_6">顺序迭代合并后的排序迭代对象</h4>
<p>有一系列排序序列，想将它们合并后得到一个排序序列并在上面迭代遍历。</p>
<pre><code class="language-python">&gt;&gt;&gt; import heapq
&gt;&gt;&gt; a = [1, 4, 7, 10]
&gt;&gt;&gt; b = [2, 5, 6, 11]
&gt;&gt;&gt; for c in heapq.merge(a, b):
...     print(c)
...
1
2
4
5
6
7
10
11
</code></pre>
<p><code>heapq.merge()</code> 需要所有输入序列必须是排过序的。 特别的，它并不会预先读取所有数据到堆栈中或者预先排序，也不会对输入做任何的排序检测。它仅仅是检查所有序列的开始部分并返回最小的那个，这个过程一直会持续直到所有输入序列中的元素都被遍历完。</p>
<h3 id="operator">operator 模块</h3>
<h4 id="itemgetter">itemgetter()</h4>
<p>根据某个或某几个字典字段来排序这个列表，通过使用<code>operator</code>模块的<code>itemgetter</code>函数，可以非常容易的排序这样的数据结构：</p>
<pre><code class="language-python">rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]

from operator import itemgetter
rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))
</code></pre>
<p><code>itemgetter()</code>有时候也可以用<code>lambda</code>表达式代替，比如：</p>
<pre><code class="language-python">rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
</code></pre>
<p>使用<code>itemgetter()</code>方式会运行的稍微快点。因此，如果你对性能要求比较高的话就使用<code>itemgetter()</code>方式。</p>
<pre><code class="language-python">&gt;&gt;&gt; min(rows, key=itemgetter('uid'))
{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
&gt;&gt;&gt; max(rows, key=itemgetter('uid'))
{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
&gt;&gt;&gt;
</code></pre>
<h4 id="attrgetter">attrgetter()</h4>
<p>排序类型相同的对象，但是他们不支持原生的比较操作。</p>
<p>内置的 <code>sorted()</code> 函数有一个关键字参数 <code>key</code> ，可以传入一个 <code>callable</code> 对象给它， 这个 <code>callable</code> 对象对每个传入的对象返回一个值，这个值会被 <code>sorted</code> 用来排序这些对象。 比如，如果你在应用程序里面有一个 <code>User</code> 实例序列，并且你希望通过他们的 <code>user_id</code> 属性进行排序， 你可以提供一个以 <code>User</code> 实例作为输入并输出对应 <code>user_id</code> 值的 <code>callable</code> 对象。</p>
<pre><code class="language-python">class User:
    def __init__(self, user_id):
        self.user_id = user_id

    def __repr__(self):
        return 'User({})'.format(self.user_id)


sorted(users, key=lambda u: u.user_id)      # [User(3), User(23), User(99)]

from operator import attrgetter
sorted(users, key=attrgetter('user_id'))    # [User(3), User(23), User(99)]
</code></pre>
<h3 id="itertools">itertools 模块</h3>
<h4 id="islice">islice()</h4>
<p>用于 迭代器和生成器 上的切片操作。</p>
<h4 id="dropwhile">dropwhile()</h4>
<p>用于丢弃一个可迭代对象前面的元素。</p>
<h4 id="permutationscombinationscombinations_with_replacement">permutations()/combinations()/combinations_with_replacement()</h4>
<p>排列组合的迭代（迭代遍历一个集合中元素的所有可能的排列或组合）。</p>
<h4 id="zip_longest">zip_longest()</h4>
<p>同时迭代多个序列，并且对其长度。</p>
<h4 id="chain">chain()</h4>
<p>合并多个集合，创建迭代器。</p>
<h4 id="groupby">groupby()</h4>
<p>有一个字典或者实例的序列，然后你想根据某个特定的字段比如 date 来分组迭代访问。</p>
<p><code>itertools.groupby()</code> 函数对于这样的数据分组操作非常实用。</p>
<pre><code class="language-python">rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]

from operator import itemgetter
from itertools import groupby

# Sort by the desired field first
rows.sort(key=itemgetter('date'))
# Iterate in groups
for date, items in groupby(rows, key=itemgetter('date')):
    print(date)
    for i in items:
        print(' ', i)
</code></pre>
<p>运行结果：</p>
<pre><code>07/01/2012
  {'date': '07/01/2012', 'address': '5412 N CLARK'}
  {'date': '07/01/2012', 'address': '4801 N BROADWAY'}
07/02/2012
  {'date': '07/02/2012', 'address': '5800 E 58TH'}
  {'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'}
  {'date': '07/02/2012', 'address': '1060 W ADDISON'}
07/03/2012
  {'date': '07/03/2012', 'address': '2122 N CLARK'}
07/04/2012
  {'date': '07/04/2012', 'address': '5148 N CLARK'}
  {'date': '07/04/2012', 'address': '1039 W GRANVILLE'}
</code></pre>
<h4 id="compress">compress()</h4>
<p>它以一个 iterable 对象和一个相对应的 Boolean 选择器序列作为输入参数。 然后输出 iterable 对象中对应选择器为 True 的元素。 当需要用另外一个相关联的序列来过滤某个序列的时候，这个函数是非常有用的。 比如：</p>
<pre><code class="language-python">addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK',
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]
counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
</code></pre>
<p>将那些对应 count 值大于5的地址全部输出，可以这样做：</p>
<pre><code class="language-python">&gt;&gt;&gt; from itertools import compress
&gt;&gt;&gt; more5 = [n &gt; 5 for n in counts]
&gt;&gt;&gt; more5
[False, False, True, False, False, True, True, False]
&gt;&gt;&gt; list(compress(addresses, more5))
['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
&gt;&gt;&gt;
</code></pre>
<p>这里的关键点在于先创建一个 <code>Boolean</code> 序列，指示哪些元素符合条件。 然后 <code>compress()</code> 函数根据这个序列去选择输出对应位置为 <code>True</code> 的元素。</p>
<p>和 <code>filter()</code> 函数类似， <code>compress()</code> 也是返回的一个迭代器。因此，如果你需要得到一个列表， 那么你需要使用 <code>list()</code> 来将结果转换为列表类型。</p>
<h3 id="logging">logging 模块</h3>
<h3 id="time">time 模块</h3>
<pre><code class="language-python">import time

# 当前时间戳（秒）
ts = time.time()
print(&quot;当前时间戳:&quot;, ts, type(ts))  
# 输出示例: 1681440000.123456 &lt;class 'float'&gt;

# 时间戳 -&gt; 本地时间元组
local = time.localtime(ts)
print(&quot;本地时间元组:&quot;, local, type(local))  
# time.struct_time(tm_year=..., ...) &lt;class 'time.struct_time'&gt;

# 时间元组 -&gt; 字符串
str_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, local)
print(&quot;格式化时间字符串:&quot;, str_time, type(str_time))  
# '2025-04-10 15:30:45' &lt;class 'str'&gt;

# 字符串 -&gt; 时间元组
parsed = time.strptime(&quot;2025-01-01 12:00:00&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)
print(&quot;解析后的时间元组:&quot;, parsed, type(parsed))  
# time.struct_time(tm_year=2025, ...) &lt;class 'time.struct_time'&gt;

# 时间元组 -&gt; 时间戳
ts_from_struct = time.mktime(parsed)
print(&quot;从结构体得到时间戳:&quot;, ts_from_struct, type(ts_from_struct))  
# 1735723200.0 &lt;class 'float'&gt;
</code></pre>
<h3 id="datetime">datetime 模块</h3>
<pre><code class="language-python">from datetime import datetime, timedelta

# 当前时间
now = datetime.now()
print(&quot;当前 datetime:&quot;, now, type(now))  
# 2025-04-10 15:30:45.123456 &lt;class 'datetime.datetime'&gt;

# 自定义时间
d = datetime(2024, 12, 31, 23, 59, 59)
print(&quot;自定义 datetime:&quot;, d, type(d))  
# 2024-12-31 23:59:59 &lt;class 'datetime.datetime'&gt;

# datetime -&gt; 字符串
formatted = d.strftime(&quot;%Y/%m/%d %H:%M&quot;)
print(&quot;格式化:&quot;, formatted, type(formatted))  
# '2024/12/31 23:59' &lt;class 'str'&gt;

# 字符串 -&gt; datetime
parsed_dt = datetime.strptime(&quot;2025-03-15 08:30&quot;, &quot;%Y-%m-%d %H:%M&quot;)
print(&quot;字符串解析为 datetime:&quot;, parsed_dt, type(parsed_dt))  
# 2025-03-15 08:30:00 &lt;class 'datetime.datetime'&gt;

# 获取时间差
delta = now - parsed_dt
print(&quot;时间差:&quot;, delta, type(delta))  
# datetime.timedelta(days=..., seconds=...) &lt;class 'datetime.timedelta'&gt;

print(&quot;差多少天:&quot;, delta.days, type(delta.days))  
# 26 &lt;class 'int'&gt;
print(&quot;差多少秒:&quot;, delta.total_seconds(), type(delta.total_seconds()))  
# 2276400.0 &lt;class 'float'&gt;

# 加减时间
future = now + timedelta(days=7)
print(&quot;7天后:&quot;, future, type(future))  
# &lt;class 'datetime.datetime'&gt;
past = now - timedelta(hours=3)
print(&quot;3小时前:&quot;, past, type(past))  
# &lt;class 'datetime.datetime'&gt;

# datetime -&gt; 时间戳
timestamp = now.timestamp()
print(&quot;当前 datetime 转时间戳:&quot;, timestamp, type(timestamp))  
# 1681440000.0 &lt;class 'float'&gt;

# 时间戳 -&gt; datetime
from_ts = datetime.fromtimestamp(timestamp)
print(&quot;时间戳转 datetime:&quot;, from_ts, type(from_ts))  
# &lt;class 'datetime.datetime'&gt;

# ISO 格式时间（标准格式）
iso_str = now.isoformat()
print(&quot;ISO 格式:&quot;, iso_str, type(iso_str))  
# '2025-04-10T15:30:45.123456' &lt;class 'str'&gt;

# 获取当前 UTC 时间
utc_now = datetime.utcnow()
print(&quot;当前 UTC 时间:&quot;, utc_now, type(utc_now))  
# &lt;class 'datetime.datetime'&gt;

# 替换 datetime 中的部分值
new_time = now.replace(hour=0, minute=0)
print(&quot;替换后的时间:&quot;, new_time, type(new_time))  
# &lt;class 'datetime.datetime'&gt;
</code></pre>
<table>
<thead>
<tr>
<th>内容</th>
<th>示例输出类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间戳</td>
<td><code>&lt;class 'float'&gt;</code></td>
</tr>
<tr>
<td>时间元组</td>
<td><code>&lt;class 'time.struct_time'&gt;</code></td>
</tr>
<tr>
<td>格式化字符串时间</td>
<td><code>&lt;class 'str'&gt;</code></td>
</tr>
<tr>
<td><code>datetime</code> 对象</td>
<td><code>&lt;class 'datetime.datetime'&gt;</code></td>
</tr>
<tr>
<td>时间差对象</td>
<td><code>&lt;class 'datetime.timedelta'&gt;</code></td>
</tr>
<tr>
<td><code>total_seconds()</code></td>
<td><code>&lt;class 'float'&gt;</code></td>
</tr>
<tr>
<td><code>days</code> 属性</td>
<td><code>&lt;class 'int'&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="time-datetime">time 和 datetime 对比</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th><code>time</code> 模块</th>
<th><code>datetime</code> 模块</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间戳操作</td>
<td>✅ <code>time.time()</code></td>
<td>✅ <code>datetime.timestamp()</code></td>
</tr>
<tr>
<td>字符串格式化</td>
<td>✅ <code>strftime</code> / <code>strptime</code></td>
<td>✅ 同样支持</td>
</tr>
<tr>
<td>时间差计算</td>
<td>❌（需手动计算）</td>
<td>✅ <code>datetime - datetime</code></td>
</tr>
<tr>
<td>加减时间</td>
<td>❌（需要封装）</td>
<td>✅ 使用 <code>timedelta</code></td>
</tr>
<tr>
<td>可读性 &amp; OOP</td>
<td>较底层</td>
<td>更直观、更强大</td>
</tr>
</tbody>
</table>
<h3 id="pytz">pytz 模块</h3>
<p>对几乎所有涉及到时区的问题，都应该使用 <code>pytz</code> 模块。这个包提供了Olson时区数据库， 它是时区信息的事实上的标准，在很多语言和操作系统里面都可以找到。</p>
<p><code>pytz</code> 模块一个主要用途是将 datetime 库创建的简单日期对象本地化。 比如，下面如何表示一个芝加哥时间的示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; from pytz import timezone
&gt;&gt;&gt; d = datetime(2012, 12, 21, 9, 30, 0)
&gt;&gt;&gt; print(d)
2012-12-21 09:30:00
&gt;&gt;&gt;

&gt;&gt;&gt; # Localize the date for Chicago
&gt;&gt;&gt; central = timezone('US/Central')
&gt;&gt;&gt; loc_d = central.localize(d)
&gt;&gt;&gt; print(loc_d)
2012-12-21 09:30:00-06:00
&gt;&gt;&gt;
</code></pre>
<h3 id="os">os 模块</h3>
<h4 id="_7">八进制</h4>
<pre><code class="language-python">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.chmod('script.py', 0755)
    File &quot;&lt;stdin&gt;&quot;, line 1
        os.chmod('script.py', 0755)
                            ^
SyntaxError: invalid token
&gt;&gt;&gt;

# 需确保八进制数的前缀是 0o 
&gt;&gt;&gt; os.chmod('script.py', 0o755)
&gt;&gt;&gt;

</code></pre>
<h3 id="operator_1">operator 模块</h3>
<h3 id="math">math 模块</h3>
<h4 id="_8">数学函数</h4>
<pre><code class="language-python">import math
print(f&quot;math.ceil(3.2) = {math.ceil(3.2)}&quot;)  # 输出: math.ceil(3.2) = 4 (向上取整)
print(f&quot;math.floor(3.8) = {math.floor(3.8)}&quot;)  # 输出: math.floor(3.8) = 3 (向下取整)
print(f&quot;math.trunc(-3.7) = {math.trunc(-3.7)}&quot;)  # 输出: math.trunc(-3.7) = -3 (截断小数部分)
</code></pre>
<h3 id="decimal">decimal 模块</h3>
<p>精确计算浮点数（并能容忍一定的性能损耗）。</p>
<p><code>decimal</code> 模块主要用在涉及到金融的领域。 在这类程序中，哪怕是一点小小的误差在计算过程中蔓延都是不允许的。 因此， <code>decimal</code> 模块为解决这类问题提供了方法。 当Python和数据库打交道的时候也通常会遇到 <code>Decimal</code> 对象，并且，通常也是在处理金融数据的时候。</p>
<pre><code class="language-python">&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; a = Decimal('4.2')
&gt;&gt;&gt; b = Decimal('2.1')
&gt;&gt;&gt; a + b
Decimal('6.3')
&gt;&gt;&gt; print(a + b)
6.3
&gt;&gt;&gt; (a + b) == Decimal('6.3')
True
</code></pre>
<h3 id="fractions">fractions 模块</h3>
<p><code>fractions</code> 模块可以被用来执行包含分数的数学运算。比如：</p>
<pre><code class="language-python">&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; a = Fraction(5, 4)
&gt;&gt;&gt; b = Fraction(7, 16)
&gt;&gt;&gt; print(a + b)
27/16
&gt;&gt;&gt; print(a * b)
35/64

&gt;&gt;&gt; # Getting numerator/denominator
&gt;&gt;&gt; c = a * b
&gt;&gt;&gt; c.numerator
35
&gt;&gt;&gt; c.denominator
64

&gt;&gt;&gt; # Converting to a float
&gt;&gt;&gt; float(c)
0.546875

&gt;&gt;&gt; # Limiting the denominator of a value
&gt;&gt;&gt; print(c.limit_denominator(8))
4/7

&gt;&gt;&gt; # Converting a float to a fraction
&gt;&gt;&gt; x = 3.75
&gt;&gt;&gt; y = Fraction(*x.as_integer_ratio())
&gt;&gt;&gt; y
Fraction(15, 4)
&gt;&gt;&gt;
</code></pre>
<h3 id="random">random 模块</h3>
<p><code>random</code>模块有大量的函数用来产生随机数和随机选择元素。 比如，要想从一个序列中随机的抽取一个元素，可以使用 random.choice() ：</p>
<pre><code class="language-python">&gt;&gt;&gt; import random
&gt;&gt;&gt; values = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; random.choice(values)
2
&gt;&gt;&gt; random.choice(values)
3
&gt;&gt;&gt; random.choice(values)
1
&gt;&gt;&gt; random.choice(values)
4
&gt;&gt;&gt; random.choice(values)
6
&gt;&gt;&gt;
</code></pre>
<p>为了提取出N个不同元素的样本用来做进一步的操作，可以使用 <code>random.sample()</code> ：</p>
<pre><code class="language-python">&gt;&gt;&gt; random.sample(values, 2)
[6, 2]
&gt;&gt;&gt; random.sample(values, 2)
[4, 3]
&gt;&gt;&gt; random.sample(values, 3)
[4, 3, 1]
&gt;&gt;&gt; random.sample(values, 3)
[5, 4, 1]
&gt;&gt;&gt;
</code></pre>
<p>打乱序列中元素的顺序，可以使用 <code>random.shuffle()</code> ：</p>
<pre><code class="language-pythoon">&gt;&gt;&gt; random.shuffle(values)
&gt;&gt;&gt; values
[2, 4, 6, 5, 3, 1]
&gt;&gt;&gt; random.shuffle(values)
&gt;&gt;&gt; values
[3, 5, 2, 1, 6, 4]
&gt;&gt;&gt;
</code></pre>
<p>生成随机整数，请使用 random.randint() ：</p>
<pre><code class="language-python">&gt;&gt;&gt; random.randint(0,10)
2
&gt;&gt;&gt; random.randint(0,10)
5
&gt;&gt;&gt; random.randint(0,10)
0
&gt;&gt;&gt; random.randint(0,10)
7
&gt;&gt;&gt; random.randint(0,10)
10
&gt;&gt;&gt; random.randint(0,10)
3
&gt;&gt;&gt;
</code></pre>
<p>为了生成0到1范围内均匀分布的浮点数，使用 <code>random.random()</code> ：</p>
<pre><code>&gt;&gt;&gt; random.random()
0.9406677561675867
&gt;&gt;&gt; random.random()
0.133129581343897
&gt;&gt;&gt; random.random()
0.4144991136919316
&gt;&gt;&gt;
</code></pre>
<p>如果要获取N位随机位(二进制)的整数，使用 random.getrandbits() ：</p>
<pre><code class="language-python">&gt;&gt;&gt; random.getrandbits(200)
335837000776573622800628485064121869519521710558559406913275
&gt;&gt;&gt;
</code></pre>
<h3 id="struct">struct 模块</h3>
<h3 id="hashlib">hashlib 模块</h3>
<h3 id="statistics">statistics 模块</h3>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../04_python%E7%AE%97%E6%B3%95/" class="btn btn-neutral float-left" title="python 算法"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../06_%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93/" class="btn btn-neutral float-right" title="常用三方库">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../04_python%E7%AE%97%E6%B3%95/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../06_%E5%B8%B8%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
